---
title: docker深入
tags: docker 运维
---
## docker run 背后的操作：
>
1.检查本地是否存在指定的镜像，不存在从仓库下载；
2.利用镜像创建一个容器，并启动；
3.分配一个文件系统给容器，并在只读的镜像外层挂载一个可读写层；
4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；
5.从网桥的地址池配置一个IP给容器；
6.执行用户指定的应用程序；
7.执行完毕后容器被自动终止；
## build
>
docker build [选项] <上下文路径/URL/->
首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。
Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。
也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。
当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？
这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。
如果在 Dockerfile 中这么写：COPY ./package.json /app/
这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。
因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。
现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。

## docker load vs docker import
> docker load导入镜像存储到本地镜像库
docker import导入一个容器快照到本地镜像库。
区别在于：容器快照文件会丢弃所有的历史记录和元数据信息，仅保存容器当时的快照状态，而镜像文件则保存完整记录，体积更大；
另外从容器导入快照文件可以重新指定标签等元数据信息；
![配置指令](/assets/images/dk1@2x.png)
![操作指令](/assets/images/dk2@2x.png)
![网络原理](/assets/images/net1@2x.png)
![网络原理](/assets/images/net2@2x.png)
![网络原理](/assets/images/net3@2x.png)
![网络原理](/assets/images/net4@2x.png)
![网络原理](/assets/images/net5@2x.png)
![网络原理](/assets/images/net6@2x.png)